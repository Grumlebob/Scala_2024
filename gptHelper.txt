
I prefer readability.
I like each calculation to have their own val/ def / line of code, if possible.
Meaning to use intermediate variables:
So returned tuples should for example be:
NextElement =...
NextState =...
(NextElement, NextState)

If you use a foldRight/Left, i like to have it split into intermediate steps like:
val initAcc = ...
def folder = ...
list.foldRight(initAcc)(folder)

I prefer clearly named variables and parameters, such as countOfStudents instead of 'n'.
But don't change the name of the method.

I have different rankings of how much the teacher likes different coding styles:
BEST:
variables using val
value bindings
expression values
parametric polymorphism
Composed dedicated higher order functions
Using dedicated API if possible such as State
Options or Either monad

MIDDLE:
simple recursion.
folds
if condition / pattern matching 

WORST:
variables using var
Return statement
any/object type
loops
exceptions

I will provide you with a custom implementation of some libraries, i want you to use those if provided.
Remember that all implementation should happen in the exam.scala file, so please don't invent new methods for the custom library implementations.

If a full signature is provided such as:
lazy val intAddition: Monoid[Int] = ???
Don't then change it to:
val intAddition: Monoid[Int] = 
In other words, don't try to change the skeleton requirements, if they are set.
But you are allowed to change parameternames to something meaningful:
def someName(f: A => B): Int =
def someName(transform: A => B): Int =
Except if it is a string in a property, then maintain the string as is:
property("Ex14.02: optionFunctor satisfies map law (tests Exercise 13)") =
property("Ex14.02: optionFunctor satisfies map law (tests Exercise 13)") =
Also maintain the names of the methods.


Don't remove existing comments.
Some exercises also require text answers, do that as a comment close to the exercise.

When you solve some exercise, please test the relevant method like this:
package adpro

import org.scalacheck.{Gen, Arbitrary}
import org.scalacheck.Arbitrary.arbitrary
import org.scalacheck.Prop.{forAll, forAllNoShrink}
import org.scalacheck.Prop
import org.scalactic.TripleEquals.*


object ExamSpec
  extends org.scalacheck.Properties("exam-2024-autumn"):

  property("A test that always passes (a sanity check)") =
    forAll { (n: Int) => n == n }

end ExamSpec

object StreamingSpec extends org.scalacheck.Properties("lazylist__"):

  /** Fixed input test cases **/
  property("00 fib(0) returns 0") = fib(0) === 0
  property("01 fib(1) returns 1") = fib(1) === 1

  /** Random input tests **/
  property("02 fib(n) satisfies recurrence relation") = 
    forAll(Gen.choose(2, 50)) { n =>
      fib(n) === fib(n - 1) + fib(n - 2)
    }

  /** LazyList behavior tests **/
  given arbLazyList[A: Arbitrary]: Arbitrary[LazyList[A]] =
    Arbitrary(summon[Arbitrary[List[A]]].arbitrary.map(LazyList(_*)))

  property("03 LazyList generates expected sequence") =
    forAll(Gen.choose(0, 10)) { start =>
      LazyList.from(start).take(5).toList == List(start, start + 1, start + 2, start + 3, start + 4)
    }

  property("04 LazyList.take returns specified number of elements") =
    forAll(Gen.choose(1, 10)) { n =>
      LazyList.from(1).take(n).toList.length == n
    }

end StreamingSpec
